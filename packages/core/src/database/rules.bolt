// ------------------------------------
// Types
// ------------------------------------

// Base Types
type Alpha extends String {
  validate() { this.test(/^[a-zA-Z]*$/) }
}

type Alphanumeric extends String{
  validate() { this.test(/^[a-zA-Z0-9]*$/) }
}

type Ascii extends String {
  validate() { this.test(/^[\x00-\x7F]+$/) }
}

type Base64 extends String {
  validate() { this.test(/[^A-Z0-9+\/=]/i) }
}

type CreditCard extends String {
  validate() { this.test(/^(?:4[0-9]{12}(?:[0-9]{3})?|5[1-5][0-9]{14}|6(?:011|5[0-9][0-9])[0-9]{12}|3[47][0-9]{13}|3(?:0[0-5]|[68][0-9])[0-9]{11}|(?:2131|1800|35\d{3})\d{11})$/) }
}

type URL extends String {
  validate() { this.startsWith('http') }
}

type DataURI extends String {
  validate() { this.test(/^\s*data:([a-z]+\/[a-z0-9\-\+]+(;[a-z\-]+\=[a-z0-9\-]+)?)?(;base64)?,[a-z0-9\!\$\&\'\,\(\)\*\+\,\;\=\-\.\_\~\:\@\/\?\%\s]*\s*$/i) }
}

type Date extends String {
  validate() { this.test(/^(-?(?:[1-9][0-9]*)?[0-9]{4})-(1[0-2]|0[1-9])-(3[01]|0[1-9]|[12][0-9])T(2[0-3]|[01][0-9]):([0-5][0-9]):([0-5][0-9])(.[0-9]+)?(Z)?$/) }
}

type PastEpoch extends Number {
  validate() { this <= now }
}

type Decimal extends String {
  validate() { this.test(/^[-+]?([0-9]+|\.[0-9]+|[0-9]+\.[0-9]+)$/) }
}

type Email extends String {
  validate() { this.test(/^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$/) }
}

type Float extends String {
  validate() { this.test(/^(?:[-+]?(?:[0-9]+))?(?:\.[0-9]*)?(?:[eE][\+\-]?(?:[0-9]+))?$/) }
}

type Hexadecimal extends String {
  validate() { this.test(/^[0-9A-F]+$/i) }
}

type HexColor extends String {
  validate() { this.test(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i) }
}

type IPv4 extends String {
  validate() { this.test(/^(\d{1,3})\.(\d{1,3})\.(\d{1,3})\.(\d{1,3})$/) }
}

type IPv6 extends String {
  validate() { this.test(/^[0-9A-F]{1,4}$/i) }
}

type ISIN extends String {
  validate() { this.test(/^[A-Z]{2}[0-9A-Z]{9}[0-9]$/) }
}

type ISO8601 extends String {
  validate() { this.test(/^([\+-]?\d{4}(?!\d{2}\b))((-?)((0[1-9]|1[0-2])(\3([12]\d|0[1-9]|3[01]))?|W([0-4]\d|5[0-2])(-?[1-7])?|(00[1-9]|0[1-9]\d|[12]\d{2}|3([0-5]\d|6[1-6])))([T\s]((([01]\d|2[0-3])((:?)[0-5]\d)?|24\:?00)([\.,]\d+(?!:))?)?(\17[0-5]\d([\.,]\d+)?)?([zZ]|([\+-])([01]\d|2[0-3]):?([0-5]\d)?)?)?)?$/) }
}

type LowercaseAlpha extends String {
  validate() { this.test(/^[a-z]$/) }
}

type UppercaseAlpha extends String {
  validate() { this.test(/^[A-Z]$/) }
}

type MACAddress extends String {
  validate() { this.test(/^([0-9a-fA-F][0-9a-fA-F]:){5}([0-9a-fA-F][0-9a-fA-F])$/) }
}

type SocialSecurity extends String {
  validate() { this.test(/^\d\d\d-\d\d-\d\d\d\d$/) }
}

type Multibyte extends String {
  validate() { this.test(/[^\x00-\x7F]/) }
}

type UUID extends String {
  validate() { this.test(/^[0-9A-F]{8}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{4}-[0-9A-F]{12}$/i) }
}

type Price extends Number {
  validate() { this >= 0 }
}

type PhoneNumber extends String {
  validate() {
    this.test(/^\+357\d{8}$/i) // Cyprus only
  }
}

type PositiveNumber extends Number {
  validate() {
    this > 0
  }
}

type InitialTimestamp extends PastEpoch {
  validate() { initial(this, now) }
}

type Geoposition {
  latitude: Number,
  longitude: Number,
}

type Address {
  street: String | Null,
  city: String | Null
  postalCode: String | Null,
  country: String,
}

type Location {
  geoposition: Geoposition,
  address: Address,
  from: String
}

// Application Types
type Locale {
  id: String,
  language: String,
  region: String,
}

type Country {
  code: String,
  name: String,
  geoposition: Geoposition,
  default: Boolean | Null,
}

type Category {
  name: String,
  categories: Map<String, SubCategory>,
}

type SubCategory {
  name: String,
}

type Dimension {
  width: PositiveNumber,
  height: PositiveNumber,
  type: String,
}

type Image {
  downloadURL: URL,
  fullPath: String,
  name: String,
  // createdAt: InitialTimestamp,
  // FIXME: this should be InitialTimestamp, but because Images are copied from
  // drafts to pendingReview, validation will fail. Instead, we should store draft - images
  // in a different collection (e.g. draftImages), and move them in a firebase-function
  // on pendingReviewAd create.
  createdAt: PastEpoch,
  dimensions: Dimension | Null,
}

type AdTitle extends String {
  validate() { this.length > 0 && this.length <= 60 }
}

type AdBody extends String {
  validate() { this.length <= 2000 }
}

type LegacyAd {
  title: AdTitle,
  body: AdBody,
  price: Price,
  location: Location,
  category: String,
  email: Email | Null,
  phone: String | Null,
  createdAt: PastEpoch,
}

type Ad {
  title: AdTitle,
  body: AdBody,
  price: Price,
  location: Location,
  category: String,
  user: String,
  sold: Boolean | Null,
  createdAt: PastEpoch,
}

type PendingReviewAd {
  title: AdTitle,
  body: AdBody,
  price: Price,
  category: String,
  user: String,
  images: Map<String, Image>,
}

type DraftAd {
  title: String | Null,
  body: String | Null,
  price: Price | Null,
  category: String | Null,
  images: Map<String, Image> | Null,
}

type Provider {
  displayName: String | Null,
  email: Email | Null,
  phoneNumber: PhoneNumber | Null,
  photoURL: URL | Null,
  providerId: String,
  uid: String,

  validate() {
    requireWhenAuthenticatedWithSocial(this.displayName, this.providerId) &&
    requireWhenAuthenticatedWithSocial(this.email, this.providerId) &&
    requireWhenAuthenticatedWithPhone(this.phoneNumber, this.providerId) &&
    requireWhenAuthenticatedWithSocial(this.photoURL, this.providerId)
  }
}

type ProfileImage {
  downloadURL: URL, // URL returned from firebase
  providerId: String,
  fullPath: String | Null, // Storage path to large-size image downloaded from `providerId`
}

type Profile {
  displayName: String | Null,
  image: ProfileImage | Null,
  phone: PhoneNumber | Null,
  providerIds: Map<String, Any> | Null
}

type User {
  email: Email | Null,
  providerData: Map<String, Provider> | Null,
  locale: String | Null,
  location: Location | Null,
  ip: IPv4 | Null,
  profile: Profile | Null,
}

type Conversation {
  ad: String,
  buyer: String,
  read: Boolean | Null,
  lastMessageCreatedAt: PastEpoch,
}

type Message {
  body: String,
  fromBuyer: Boolean,
  read: Boolean | Null,
  createdAt: PastEpoch | Null,
}

type SupportMessageBody extends String {
  validate() { this.length > 0 && this.length <= 400 }
}

type SupportMessage {
  email: Email,
  subject: String | Null,
  body: SupportMessageBody
}

// ------------------------------------
// Functions
// ------------------------------------
isAuthenticated() { auth != null }
isAuthenticatedWithPhone() { auth != null && auth.provider == 'phone' }
isCurrentUser(uid) { auth != null && auth.uid == uid }
categoryIsValid(categoryId) { root.categories[categoryId] != null }
adIsValid(adId) { root.ads.published[adId] != null || root.ads.legacy[adId] != null }
userIsValid(uid) { root.users[uid] != null }
localeIsValid(localeId) { root.locales[localeId] != null }
isSocialProvider(providerId) { providerId == 'google' || providerId == 'facebook.com' || providerId == 'twitter' || providerId == 'github' }
requireWhenAuthenticatedWithSocial(value, providerId) { value != null || !isSocialProvider(providerId) }
requireWhenAuthenticatedWithPhone(value, providerId) { value != null || providerId != 'phone' }
createOnly(value) { prior(value) == null || value == prior(value) }
initial(value, init) { value == (prior(value) == null ? init : prior(value)) }
isSeller(adId) { auth != null && root.ads.byUser[auth.uid][adId] != null }
valueIsNow(value) { value == now }
requireUserHasIp(userId) { root.users[userId].ip != null }

// ------------------------------------
// Paths
// ------------------------------------
path /locales is Locale[] {
  read() { true }
  index() { ['default'] }
}

path /translations {
  read() { true }
}

path /countries is Country[] {
  read() { true }
  index() { ['default'] }
}

path /categories is Category[] {
  read() { true }
}

path /ads/legacy/{id} {
  read() { true }

  validate() {
    categoryIsValid(this.category) &&
    createOnly(this.createdAt) &&
    (this.email != null || this.phone != null)
  }
}

// TODO: This doesn't work when updating the ad:
// path /ads/published/{id} is Ad {
path /ads/published/{id} {
  read() { true }
  update() { isSeller(id) }

  validate() {
    categoryIsValid(this.category) &&
    createOnly(this.createdAt) &&
    (this.sold == null || this.sold == true)
  }
}

path /ads/pendingReview/{id} is PendingReviewAd {
  read() { true }

  // TODO: Temporarily require phone-number auth, until merging-accounts is implemented
  // create() { isAuthenticatedWithPhone() }
  create() { isCurrentUser(this.user) }

  validate() {
    this.images != null &&
    categoryIsValid(this.category) &&
    requireUserHasIp(this.user)
  }
}

path /ads/draft/{uid} is DraftAd {
  read() { isCurrentUser(uid) }
  create() { isCurrentUser(uid) }
  update() { isCurrentUser(uid) }
  delete() { isCurrentUser(uid) }
}

path /ads/byUser/{uid} {
  read() { true }
}

path /ads/byUser/{uid}/{adId} {
  create() { isCurrentUser(uid) && (root.ads.published[adId] != null) }
  delete() { isCurrentUser(uid) && (root.ads.published[adId] == null) }

  validate() {
    this == true && // Allow only setting to `true`
    uid == root.ads[adId].user
  }
}

path /ads/images/{adId} {
  read() { true }
}

path /ads/images/{adId}/{imageId} is Image {
  write() { isSeller(adId) }

  validate() {
    adIsValid(adId)
  }
}

path /users/{uid} is User {
  read() { isCurrentUser(uid) }
  create() { true } // TODO: is this right?
  update() { isCurrentUser(uid) }

  validate() {
    requireWhenAuthenticatedWithSocial(this.profile, auth.provider) &&
    (this.locale == null || localeIsValid(this.locale))
  }
}

path /users/{uid}/profile is Profile {
  read() { true }
}

path /favorites/{uid} {
  read() { isCurrentUser(uid) }
}

path /favorites/{uid}/{adId} {
  read() { isCurrentUser(uid) }
  create() { isCurrentUser(uid) }
  delete() { isCurrentUser(uid) }

  validate() {
    adIsValid(adId)
  }
}

path /myConversations/{uid} {
  read() { isCurrentUser(uid) }
}

path /myConversations/{uid}/{adIdBuyerId} is Conversation {
  read() { isCurrentUser(uid) }

  index() { return ['lastMessageCreatedAt'] }
}

path /myConversations/{uid}/{adIdBuyerId}/read is Boolean {
  update() { isCurrentUser(uid) }
}

path /myConversations/{uid}/{adIdBuyerId}/read {
  create() { isCurrentUser(uid) }
  update() { isCurrentUser(uid) }

  validate() {
    // Disallow setting to unread
    this == true
  }
}

path /messages/{adId}/{buyerId} {
  read() { isCurrentUser(buyerId) || isSeller(adId) }
}

path /messages/{adId}/{buyerId}/{messageId} is Message {
  create() { isCurrentUser(buyerId) || isSeller(adId) }
  update() { (this.fromBuyer && isCurrentUser(buyerId)) || (!this.fromBuyer && isSeller(adId)) }
  delete() { (this.fromBuyer && isCurrentUser(buyerId)) || (!this.fromBuyer && isSeller(adId)) }

  validate() {
    this.body.length > 0 &&
    userIsValid(buyerId) &&
    adIsValid(adId) &&
    ((this.fromBuyer && !isSeller(adId)) || (!this.fromBuyer && isSeller(adId))) &&
    buyerId != root.ads[adId].user // seller can't send message to self
  }
}

path /messages/{adId} {
  read() { isSeller(adId) }
}

path /support/{id} is SupportMessage {
  create() { true }
}
